from sys import path
path.append("../APTED/apted")
path.append("util/")

import clip_caption_generator
import constants
import json
import requests
import datetime
import subprocess
import shlex
import urllib
import glob
import os
import extract_frames


def qik_search(query_video, fetch_count=None):
    obj_res = None

    captionRanksDict = {}
    sortedCaptionRanksDict = {}

    # Noting the time taken for further auditing.
    time = datetime.datetime.now()

    # Initial Loading of the caption generator model.
    clip_caption_generator.init()

    # Deleting scenes detected during previous executions
    os.system('rm -rf %s/*' % constants.QIK_SCENES_PATH)

    # Detecting key scenes of the input video.
    # subprocess.call(shlex.split("scenedetect -i " + query_video + " detect-content list-scenes -n save-images"), cwd = constants.QIK_SCENES_PATH)
    subprocess.call(shlex.split("scenedetect -i " + query_video + " detect-content list-scenes -n save-images -o " + constants.QIK_SCENES_PATH))
    # extract_frames.extract_key_scenes(query_video, constants.QIK_SCENES_PATH)

    # Initializing a list to hold the captions and the associated dependency trees.
    captions_lst = []

    # Iterating over the scenes detected.
    for image in glob.iglob(constants.QIK_SCENES_PATH + '/*.jpg'):

        # Generating the captions.
        caption = clip_caption_generator.get_captions(image)

        # Handling the fullstops in captions.
        if caption[-1] == '.':
            caption = caption[:-1].strip()
        print("qik_search.py :: qik_search :: caption :: ", caption)

        # Adding the caption to the list.
        captions_lst.append(caption)

    # Creating the request JSON.
    json_data = {'captionsArr': captions_lst}

    # Querying the backend to fetch the list of images and captions.
    # GET Request
    # cap_req = constants.INDEX_ENGINE_QUERY_URL + urllib.parse.quote(str(json_data))
    # print("qik_search.py :: qik_search :: QIK Captions Request :: ", cap_req)
    # cap_res = requests.get(cap_req).text

    # POST Request
    print("json_data :: ", json_data)
    res = requests.post(constants.INDEX_ENGINE_QUERY_URL, data=json.dumps(json_data), headers={'Content-Type': 'application/json', 'Accept':'application/json'}, timeout=7200).text

    cap_res = requests.post(constants.INDEX_ENGINE_QUERY_URL, data=json.dumps(json_data), headers={'Content-Type': 'application/json', 'Accept':'application/json'}).text
    print("qik_search.py :: cap_res :: ", cap_res)

    # Auditing the scene and their ids for analysis.
    with open("/mydata/Scene_Analysis.txt", 'a+') as f:
        f.write(query_video + "=" + str(cap_res) + "\n")

    # Forming the return image set.
    if cap_res is not None:
        res = json.loads(cap_res)
        print("qik_search.py :: qik_search :: QIK Fetch Execution time :: ", (datetime.datetime.now() - time))

        for resMap in res:
            image = resMap['fileURL']

            # Temp Fix done to replace Tomcat IP. Needs to be handled in the IndexEngine.
            image_path = image.replace(constants.TOMCAT_OLD_IP_ADDR, constants.TOMCAT_IP_ADDR)

            # Check if the captionRanksDict contains the file
            if (image_path + ":: ") in captionRanksDict:
                # Ranking the results based on the number of captions matched
                captionRanksDict[image_path + ":: "] = captionRanksDict[image_path + ":: "] + 1
            else:
                captionRanksDict[image_path + ":: "] = 1
        print(captionRanksDict)

        # Formating done for Ranking
        sortedCaptionRanksDict = sorted(captionRanksDict.items(), key=lambda kv: kv[1], reverse=True)

    # Auditing the QIK execution time.
    print("QIK Execution time :: ", (datetime.datetime.now() - time))

    if sortedCaptionRanksDict and fetch_count is not None:
        print("sortedCaptionRanksDict :: ", sortedCaptionRanksDict[:fetch_count])
        return sortedCaptionRanksDict[:fetch_count]
    else:
        print("sortedCaptionRanksDict :: ", sortedCaptionRanksDict)
        return sortedCaptionRanksDict